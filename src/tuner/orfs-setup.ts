/**
 * ORFS Setup Utility for AutoTuner
 *
 * Creates the proper OpenROAD-flow-scripts directory structure
 * required by the ORFS AutoTuner.
 *
 * ORFS expects:
 * /foss/tools/OpenROAD-flow-scripts/flow/designs/<platform>/<design>/
 *   ├── config.mk          # Makefile-based config
 *   └── constraint.sdc     # Timing constraints
 * /foss/tools/OpenROAD-flow-scripts/flow/designs/src/<design>/
 *   └── <design>.v         # Verilog source
 */

import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

const execAsync = promisify(exec);

const CONTAINER_NAME = process.env.DOCKER_CONTAINER_NAME || "mcp4eda";

/**
 * Execute a command in the Docker container
 */
async function execInDocker(command: string): Promise<{ success: boolean; output?: string; error?: string }> {
  try {
    const { stdout, stderr } = await execAsync(
      `docker exec ${CONTAINER_NAME} bash -c "${command.replace(/"/g, '\\"')}"`,
      { timeout: 30000, maxBuffer: 10 * 1024 * 1024 }
    );
    return { success: true, output: stdout };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Write content to a file in the Docker container using docker cp
 * This avoids Windows command line length limits
 */
async function writeFileToDocker(content: string, containerPath: string): Promise<{ success: boolean; error?: string }> {
  const tempDir = os.tmpdir();
  const tempFile = path.join(tempDir, `mcp4eda_${Date.now()}_${Math.random().toString(36).substring(7)}`);

  try {
    // Write to temp file on host
    fs.writeFileSync(tempFile, content, "utf8");

    // Copy to container
    await execAsync(`docker cp "${tempFile}" ${CONTAINER_NAME}:${containerPath}`, { timeout: 30000 });

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  } finally {
    // Clean up temp file
    try {
      if (fs.existsSync(tempFile)) {
        fs.unlinkSync(tempFile);
      }
    } catch {
      // Ignore cleanup errors
    }
  }
}

/**
 * Platform mapping for ORFS
 */
const PLATFORM_MAP: Record<string, string> = {
  "sky130A": "sky130hd",
  "sky130B": "sky130hd",
  "sky130hd": "sky130hd",
  "sky130hs": "sky130hs",
  "gf180mcuD": "gf180",
  "gf180": "gf180",
  "ihp-sg13g2": "ihp-sg13g2",
  "asap7": "asap7",
};

/**
 * ORFS design configuration
 */
export interface ORFSDesignConfig {
  designName: string;
  platform: string;
  verilogCode: string;
  clockPort: string;
  clockPeriod: number;  // in ns
  coreUtilization?: number;  // percentage, default 40
  aspectRatio?: number;  // default 1.0
  dieArea?: { width: number; height: number };  // optional fixed die size
  existingSdcContent?: string;  // Use existing SDC if provided, otherwise generate
  existingConfigMkContent?: string;  // Use existing config.mk if provided, otherwise generate
}

/**
 * Generate config.mk content for ORFS
 */
export function generateConfigMk(config: ORFSDesignConfig): string {
  const platform = PLATFORM_MAP[config.platform] || "sky130hd";
  const utilization = config.coreUtilization || 40;
  const aspectRatio = config.aspectRatio || 1.0;

  let configMk = `# Generated by MCP4EDA for ORFS AutoTuner
export DESIGN_NAME = ${config.designName}
export PLATFORM    = ${platform}

export VERILOG_FILES = $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/${config.designName}.v
export SDC_FILE      = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/constraint.sdc

# Flow configuration
export CORE_UTILIZATION = ${utilization}
export ASPECT_RATIO = ${aspectRatio}
export TNS_END_PERCENT = 100
`;

  // Add optional die area constraints
  if (config.dieArea) {
    configMk += `
# Fixed die area (um)
export DIE_AREA = 0 0 ${config.dieArea.width} ${config.dieArea.height}
`;
  }

  return configMk;
}

/**
 * Generate constraint.sdc content for ORFS
 */
export function generateConstraintSdc(config: ORFSDesignConfig): string {
  const ioPct = 0.2;  // 20% of clock period for I/O delay

  return `# Generated by MCP4EDA for ORFS AutoTuner
current_design ${config.designName}

set clk_name core_clock
set clk_port_name ${config.clockPort}
set clk_period ${config.clockPeriod}
set clk_io_pct ${ioPct}

set clk_port [get_ports $clk_port_name]

create_clock -name $clk_name -period $clk_period $clk_port

set non_clock_inputs [all_inputs -no_clocks]

set_input_delay [expr $clk_period * $clk_io_pct] -clock $clk_name $non_clock_inputs
set_output_delay [expr $clk_period * $clk_io_pct] -clock $clk_name [all_outputs]
`;
}

/**
 * Setup result
 */
export interface ORFSSetupResult {
  success: boolean;
  designDir: string;
  srcDir: string;
  configMkPath: string;
  sdcPath: string;
  verilogPath: string;
  error?: string;
}

/**
 * Setup ORFS design directory structure for AutoTuner
 */
export async function setupORFSDesign(config: ORFSDesignConfig): Promise<ORFSSetupResult> {
  const platform = PLATFORM_MAP[config.platform] || "sky130hd";
  const orfsRoot = "/foss/tools/OpenROAD-flow-scripts";
  const designDir = `${orfsRoot}/flow/designs/${platform}/${config.designName}`;
  const srcDir = `${orfsRoot}/flow/designs/src/${config.designName}`;

  try {
    // Create directories
    const mkdirCmd = `mkdir -p ${designDir} ${srcDir}`;
    const mkdirResult = await execInDocker(mkdirCmd);
    if (!mkdirResult.success) {
      return {
        success: false,
        designDir,
        srcDir,
        configMkPath: "",
        sdcPath: "",
        verilogPath: "",
        error: `Failed to create directories: ${mkdirResult.error}`,
      };
    }

    // Use existing config.mk if provided, otherwise generate
    const configMk = config.existingConfigMkContent || generateConfigMk(config);
    const configMkPath = `${designDir}/config.mk`;
    const configResult = await writeFileToDocker(configMk, configMkPath);
    if (!configResult.success) {
      return {
        success: false,
        designDir,
        srcDir,
        configMkPath,
        sdcPath: "",
        verilogPath: "",
        error: `Failed to write config.mk: ${configResult.error}`,
      };
    }

    // Use existing SDC if provided, otherwise generate
    const sdc = config.existingSdcContent || generateConstraintSdc(config);
    const sdcPath = `${designDir}/constraint.sdc`;
    const sdcResult = await writeFileToDocker(sdc, sdcPath);
    if (!sdcResult.success) {
      return {
        success: false,
        designDir,
        srcDir,
        configMkPath,
        sdcPath,
        verilogPath: "",
        error: `Failed to write constraint.sdc: ${sdcResult.error}`,
      };
    }

    // Write Verilog source using docker cp to avoid command line length limits
    const verilogPath = `${srcDir}/${config.designName}.v`;
    const verilogResult = await writeFileToDocker(config.verilogCode, verilogPath);
    if (!verilogResult.success) {
      return {
        success: false,
        designDir,
        srcDir,
        configMkPath,
        sdcPath,
        verilogPath,
        error: `Failed to write Verilog: ${verilogResult.error}`,
      };
    }

    // Verify all files exist
    const verifyCmd = `ls -la ${configMkPath} ${sdcPath} ${verilogPath}`;
    const verifyResult = await execInDocker(verifyCmd);
    if (!verifyResult.success) {
      return {
        success: false,
        designDir,
        srcDir,
        configMkPath,
        sdcPath,
        verilogPath,
        error: `Verification failed: ${verifyResult.error}`,
      };
    }

    return {
      success: true,
      designDir,
      srcDir,
      configMkPath,
      sdcPath,
      verilogPath,
    };
  } catch (error) {
    return {
      success: false,
      designDir,
      srcDir,
      configMkPath: "",
      sdcPath: "",
      verilogPath: "",
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Cleanup ORFS design directory
 */
export async function cleanupORFSDesign(designName: string, platform: string): Promise<boolean> {
  const platformMapped = PLATFORM_MAP[platform] || "sky130hd";
  const orfsRoot = "/foss/tools/OpenROAD-flow-scripts";
  const designDir = `${orfsRoot}/flow/designs/${platformMapped}/${designName}`;
  const srcDir = `${orfsRoot}/flow/designs/src/${designName}`;

  try {
    const cleanupCmd = `rm -rf ${designDir} ${srcDir}`;
    const result = await execInDocker(cleanupCmd);
    return result.success;
  } catch {
    return false;
  }
}

/**
 * Check if ORFS design exists
 */
export async function checkORFSDesignExists(designName: string, platform: string): Promise<boolean> {
  const platformMapped = PLATFORM_MAP[platform] || "sky130hd";
  const orfsRoot = "/foss/tools/OpenROAD-flow-scripts";
  const configMkPath = `${orfsRoot}/flow/designs/${platformMapped}/${designName}/config.mk`;

  try {
    const checkCmd = `test -f ${configMkPath} && echo "exists"`;
    const result = await execInDocker(checkCmd);
    return result.success && (result.output?.includes("exists") ?? false);
  } catch {
    return false;
  }
}

/**
 * Copy Verilog from MCP4EDA project to ORFS structure
 */
export async function copyProjectToORFS(
  projectDir: string,
  designName: string,
  platform: string,
  clockPort: string,
  clockPeriod: number
): Promise<ORFSSetupResult> {
  try {
    // Read Verilog from project directory
    const readCmd = `cat ${projectDir}/src/${designName}.v 2>/dev/null || cat ${projectDir}/${designName}.v 2>/dev/null`;
    const readResult = await execInDocker(readCmd);

    if (!readResult.success || !readResult.output) {
      return {
        success: false,
        designDir: "",
        srcDir: "",
        configMkPath: "",
        sdcPath: "",
        verilogPath: "",
        error: "Could not read Verilog source from project directory",
      };
    }

    // Setup ORFS with the Verilog code
    return setupORFSDesign({
      designName,
      platform,
      verilogCode: readResult.output,
      clockPort,
      clockPeriod,
    });
  } catch (error) {
    return {
      success: false,
      designDir: "",
      srcDir: "",
      configMkPath: "",
      sdcPath: "",
      verilogPath: "",
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Get platform directory name for ORFS
 */
export function getORFSPlatform(pdk: string): string {
  return PLATFORM_MAP[pdk] || "sky130hd";
}
